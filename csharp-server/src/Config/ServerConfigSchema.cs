// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using HandInHand.Config;
//
//    var serverConfigSchema = ServerConfigSchema.FromJson(jsonString);

namespace HandInHand.Config
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// Configuration schema for all 4 language servers (Node.js, Python, Go, C#)
    /// </summary>
    public partial class ServerConfigSchema
    {
        [JsonProperty("api")]
        public Api Api { get; set; }

        [JsonProperty("cors")]
        public Cors Cors { get; set; }

        /// <summary>
        /// Enable debug mode
        /// </summary>
        [JsonProperty("debug")]
        public bool Debug { get; set; }

        /// <summary>
        /// Current environment
        /// </summary>
        [JsonProperty("environment")]
        public Environment Environment { get; set; }

        [JsonProperty("jsonrpc")]
        public Jsonrpc Jsonrpc { get; set; }

        [JsonProperty("logging")]
        public Logging Logging { get; set; }

        [JsonProperty("nginx")]
        public Nginx Nginx { get; set; }

        [JsonProperty("redis")]
        public Redis Redis { get; set; }

        [JsonProperty("servers")]
        public Servers Servers { get; set; }

        [JsonProperty("sse")]
        public Sse Sse { get; set; }
    }

    public partial class Api
    {
        /// <summary>
        /// API base path
        /// </summary>
        [JsonProperty("base_path")]
        public string BasePath { get; set; }

        [JsonProperty("rate_limit")]
        public RateLimit RateLimit { get; set; }

        /// <summary>
        /// Enable Swagger documentation
        /// </summary>
        [JsonProperty("swagger_enabled")]
        public bool SwaggerEnabled { get; set; }

        /// <summary>
        /// API version
        /// </summary>
        [JsonProperty("version")]
        public string Version { get; set; }
    }

    public partial class RateLimit
    {
        /// <summary>
        /// Maximum requests per window
        /// </summary>
        [JsonProperty("max_requests")]
        public long MaxRequests { get; set; }

        /// <summary>
        /// Rate limit window in milliseconds
        /// </summary>
        [JsonProperty("window_ms")]
        public long WindowMs { get; set; }
    }

    public partial class Cors
    {
        /// <summary>
        /// Allow credentials in CORS requests
        /// </summary>
        [JsonProperty("allow_credentials")]
        public bool AllowCredentials { get; set; }

        /// <summary>
        /// Allowed HTTP headers
        /// </summary>
        [JsonProperty("allowed_headers")]
        public string[] AllowedHeaders { get; set; }

        /// <summary>
        /// Allowed HTTP methods
        /// </summary>
        [JsonProperty("allowed_methods")]
        public AllowedMethod[] AllowedMethods { get; set; }

        /// <summary>
        /// Allowed CORS origins
        /// </summary>
        [JsonProperty("allowed_origins")]
        public string[] AllowedOrigins { get; set; }
    }

    public partial class Jsonrpc
    {
        /// <summary>
        /// Maximum batch request size
        /// </summary>
        [JsonProperty("batch_limit")]
        public long BatchLimit { get; set; }

        /// <summary>
        /// Request timeout in milliseconds
        /// </summary>
        [JsonProperty("timeout")]
        public long Timeout { get; set; }

        /// <summary>
        /// JSON-RPC version
        /// </summary>
        [JsonProperty("version")]
        public Version Version { get; set; }
    }

    public partial class Logging
    {
        /// <summary>
        /// Enable console logging
        /// </summary>
        [JsonProperty("console_enabled")]
        public bool ConsoleEnabled { get; set; }

        /// <summary>
        /// Enable file logging
        /// </summary>
        [JsonProperty("file_enabled")]
        public bool FileEnabled { get; set; }

        /// <summary>
        /// Log format
        /// </summary>
        [JsonProperty("format")]
        public Format Format { get; set; }

        /// <summary>
        /// Logging level
        /// </summary>
        [JsonProperty("level")]
        public Level Level { get; set; }
    }

    public partial class Nginx
    {
        /// <summary>
        /// Health check endpoint path
        /// </summary>
        [JsonProperty("health_check_path")]
        public string HealthCheckPath { get; set; }

        /// <summary>
        /// NGINX listen port
        /// </summary>
        [JsonProperty("port")]
        public long Port { get; set; }

        /// <summary>
        /// NGINX upstream name
        /// </summary>
        [JsonProperty("upstream_name")]
        public string UpstreamName { get; set; }
    }

    public partial class Redis
    {
        /// <summary>
        /// Redis database number
        /// </summary>
        [JsonProperty("db")]
        public long Db { get; set; }

        /// <summary>
        /// Redis host address
        /// </summary>
        [JsonProperty("host")]
        public string Host { get; set; }

        /// <summary>
        /// Maximum retry attempts per request
        /// </summary>
        [JsonProperty("max_retries_per_request", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxRetriesPerRequest { get; set; }

        /// <summary>
        /// Redis password (optional)
        /// </summary>
        [JsonProperty("password", NullValueHandling = NullValueHandling.Ignore)]
        public string Password { get; set; }

        /// <summary>
        /// Redis port number
        /// </summary>
        [JsonProperty("port")]
        public long Port { get; set; }

        /// <summary>
        /// Retry delay in milliseconds
        /// </summary>
        [JsonProperty("retry_delay_on_failover", NullValueHandling = NullValueHandling.Ignore)]
        public long? RetryDelayOnFailover { get; set; }
    }

    public partial class Servers
    {
        [JsonProperty("csharp")]
        public ServerInfo Csharp { get; set; }

        [JsonProperty("golang")]
        public ServerInfo Golang { get; set; }

        [JsonProperty("nodejs")]
        public ServerInfo Nodejs { get; set; }

        [JsonProperty("python")]
        public ServerInfo Python { get; set; }
    }

    public partial class ServerInfo
    {
        /// <summary>
        /// Server host address
        /// </summary>
        [JsonProperty("host")]
        public string Host { get; set; }

        /// <summary>
        /// Server name
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// Server port number
        /// </summary>
        [JsonProperty("port")]
        public long Port { get; set; }
    }

    public partial class Sse
    {
        /// <summary>
        /// SSE heartbeat interval in milliseconds
        /// </summary>
        [JsonProperty("heartbeat_interval")]
        public long HeartbeatInterval { get; set; }

        /// <summary>
        /// Maximum SSE connections
        /// </summary>
        [JsonProperty("max_connections")]
        public long MaxConnections { get; set; }

        /// <summary>
        /// SSE reconnect timeout in milliseconds
        /// </summary>
        [JsonProperty("reconnect_timeout")]
        public long ReconnectTimeout { get; set; }
    }

    public enum AllowedMethod { Delete, Get, Head, Options, Patch, Post, Put };

    /// <summary>
    /// Current environment
    /// </summary>
    public enum Environment { Development, Production, Testing };

    /// <summary>
    /// JSON-RPC version
    /// </summary>
    public enum Version { The20 };

    /// <summary>
    /// Log format
    /// </summary>
    public enum Format { Json, Text };

    /// <summary>
    /// Logging level
    /// </summary>
    public enum Level { Debug, Error, Info, Warn };

    public partial class ServerConfigSchema
    {
        public static ServerConfigSchema FromJson(string json) => JsonConvert.DeserializeObject<ServerConfigSchema>(json, HandInHand.Config.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ServerConfigSchema self) => JsonConvert.SerializeObject(self, HandInHand.Config.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AllowedMethodConverter.Singleton,
                EnvironmentConverter.Singleton,
                VersionConverter.Singleton,
                FormatConverter.Singleton,
                LevelConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AllowedMethodConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AllowedMethod) || t == typeof(AllowedMethod?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DELETE":
                    return AllowedMethod.Delete;
                case "GET":
                    return AllowedMethod.Get;
                case "HEAD":
                    return AllowedMethod.Head;
                case "OPTIONS":
                    return AllowedMethod.Options;
                case "PATCH":
                    return AllowedMethod.Patch;
                case "POST":
                    return AllowedMethod.Post;
                case "PUT":
                    return AllowedMethod.Put;
            }
            throw new Exception("Cannot unmarshal type AllowedMethod");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AllowedMethod)untypedValue;
            switch (value)
            {
                case AllowedMethod.Delete:
                    serializer.Serialize(writer, "DELETE");
                    return;
                case AllowedMethod.Get:
                    serializer.Serialize(writer, "GET");
                    return;
                case AllowedMethod.Head:
                    serializer.Serialize(writer, "HEAD");
                    return;
                case AllowedMethod.Options:
                    serializer.Serialize(writer, "OPTIONS");
                    return;
                case AllowedMethod.Patch:
                    serializer.Serialize(writer, "PATCH");
                    return;
                case AllowedMethod.Post:
                    serializer.Serialize(writer, "POST");
                    return;
                case AllowedMethod.Put:
                    serializer.Serialize(writer, "PUT");
                    return;
            }
            throw new Exception("Cannot marshal type AllowedMethod");
        }

        public static readonly AllowedMethodConverter Singleton = new AllowedMethodConverter();
    }

    internal class EnvironmentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Environment) || t == typeof(Environment?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "development":
                    return Environment.Development;
                case "production":
                    return Environment.Production;
                case "testing":
                    return Environment.Testing;
            }
            throw new Exception("Cannot unmarshal type Environment");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Environment)untypedValue;
            switch (value)
            {
                case Environment.Development:
                    serializer.Serialize(writer, "development");
                    return;
                case Environment.Production:
                    serializer.Serialize(writer, "production");
                    return;
                case Environment.Testing:
                    serializer.Serialize(writer, "testing");
                    return;
            }
            throw new Exception("Cannot marshal type Environment");
        }

        public static readonly EnvironmentConverter Singleton = new EnvironmentConverter();
    }

    internal class VersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Version) || t == typeof(Version?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "2.0")
            {
                return Version.The20;
            }
            throw new Exception("Cannot unmarshal type Version");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Version)untypedValue;
            if (value == Version.The20)
            {
                serializer.Serialize(writer, "2.0");
                return;
            }
            throw new Exception("Cannot marshal type Version");
        }

        public static readonly VersionConverter Singleton = new VersionConverter();
    }

    internal class FormatConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Format) || t == typeof(Format?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "json":
                    return Format.Json;
                case "text":
                    return Format.Text;
            }
            throw new Exception("Cannot unmarshal type Format");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Format)untypedValue;
            switch (value)
            {
                case Format.Json:
                    serializer.Serialize(writer, "json");
                    return;
                case Format.Text:
                    serializer.Serialize(writer, "text");
                    return;
            }
            throw new Exception("Cannot marshal type Format");
        }

        public static readonly FormatConverter Singleton = new FormatConverter();
    }

    internal class LevelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Level) || t == typeof(Level?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "debug":
                    return Level.Debug;
                case "error":
                    return Level.Error;
                case "info":
                    return Level.Info;
                case "warn":
                    return Level.Warn;
            }
            throw new Exception("Cannot unmarshal type Level");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Level)untypedValue;
            switch (value)
            {
                case Level.Debug:
                    serializer.Serialize(writer, "debug");
                    return;
                case Level.Error:
                    serializer.Serialize(writer, "error");
                    return;
                case Level.Info:
                    serializer.Serialize(writer, "info");
                    return;
                case Level.Warn:
                    serializer.Serialize(writer, "warn");
                    return;
            }
            throw new Exception("Cannot marshal type Level");
        }

        public static readonly LevelConverter Singleton = new LevelConverter();
    }
}
